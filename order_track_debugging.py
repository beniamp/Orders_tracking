# -*- coding: utf-8 -*-
"""order track debugging.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hxi93wje0pXPOCK7HCKol3vfhmDBM6Nc
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from PIL import Image
from convertdate import persian
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import numpy as np

"""<h3> Creating dataframe by extracting values from  order csv file<h3>
<ul>
  <li>defining df_orders; main dataframe </li>
</ul><br>
<em>Defined Variables: df_orders</em>
"""

df_orders = pd.read_csv('Orders.csv')

"""<h3> Calculating three essential metrics that we rely on through out the program<h3>
<ul>
  <li> TotalPrice as Total final Price </li>
  <li> Quantity as Total Volume of orders </li>
  <li> TotalNetPrice as Total Net Price </li>
</ul>

<p># minor formatting so that the numbers gets divided on every thousands </p><br>

<em>Defined variables: total_sales, formatted_total_sales || total_volume, formatted_total_volume || total_net, formatted_total_net<em>

"""

# Calculate metrics
total_sales = df_orders['TotalPrice'].sum()
formatted_total_sales = "{:,}".format(total_sales)

total_volume = df_orders['Quantity'].sum()
formatted_total_volume = "{:,}".format(total_volume)

total_net = df_orders['TotalNetPrice'].sum()
formatted_total_net = "{:,}".format(total_net)

"""<h3> Simple manipulation and cleaning<h3>
<ul>
  <li> removing redundant category name (mobile phone) </li>
  <li> handling null date values </li>
  <li> sorting date values(string) in ascending order  </li>
</ul>

<p> </p><br>

<em>Defined variables: sorted_dates, categories (contains all the uniue values beside all categories option)<em>

"""

# Clean up category data
df_orders['Category'] = df_orders['Category'].replace('گوشی موبایل ', 'گوشی موبایل')
categories = ['All Categories'] + df_orders['Category'].unique().tolist()

# Formatting and cleaning date values
df_orders['Date_Formatted'] = df_orders['Date_Formatted'].fillna('0000-00-00')
df_orders = df_orders[df_orders['Date_Formatted'] != '0000-00-00']

# Ensure date is a string format
df_orders['Date_value'] = df_orders['Date_Formatted'].str.replace('-', '').astype(str)
sorted_dates = sorted(df_orders['Date_Formatted'].unique())

"""<h3> Converting persian dates in string to gregorian in datetime<h3>
<ul>
  <li> defining function which accepts string persian string and turns it into gregorian datetime </li>
  <li> spliting date by "-" character and  </li>
  <li> assigning each item into year, month and day </li>
  <li> setting two random number as start and end date for further away # note that this section does not matter in final terminal because it'll get done by widget </li>
</ul>

<p> # this section is essential for having date input widget calender-like</p><br>

<em>Defined variables: sorted_dates_gregorian (same values as sorted values expect in gregorian datetime system) || start_date, end_date<em>

"""

# Function to convert Persian date to Gregorian date
def persian_to_gregorian(persian_date_str):
    year, month, day = map(int, persian_date_str.split('-'))
    gregorian_date = persian.to_gregorian(year, month, day)
    return datetime(gregorian_date[0], gregorian_date[1], gregorian_date[2])

# Convert Persian dates to Gregorian
sorted_dates_persian = sorted_dates
sorted_dates_gregorian = [persian_to_gregorian(date) for date in sorted_dates_persian]

start_date = persian_to_gregorian(sorted_dates[125])
end_date = persian_to_gregorian(sorted_dates[140])

"""<h3> Converting gregorian dates back into persian string date values<h3>
<ul>
  <li> extracting year, month, day from gregorian dates </li>
  <li> creating standard format which is 'year-month-day'  </li>
</ul>

<p> # For better readability I need to convert them back for better displayment</p><br>

<em>Defined variables: start_date_persian, end_date_persian <em>



"""

# Convert Gregorian dates back to Persian format
def gregorian_to_persian(gregorian_date):
    persian_date = persian.from_gregorian(gregorian_date.year, gregorian_date.month, gregorian_date.day)
    return f'{persian_date[0]:04}-{persian_date[1]:02}-{persian_date[2]:02}'

# Convert the selected Gregorian dates back to Persian format
start_date_persian = gregorian_to_persian(start_date)
end_date_persian = gregorian_to_persian(end_date)

end_date

"""<h3> Calculating number of days in between<h3>
<ul>
  <li> calculating interval using start and end date </li>
  <li> measuring previous date range using 3 available values</li>
</ul><br>

<em>Defined variables: previous_start_date, previous_end_date || previous_start_date_persian, previous_end_date_persian <em>

"""

# Calculate the number of days in the selected range
num_days = (end_date - start_date).days + 1

# Calculate the previous date range
previous_start_date = start_date - timedelta(days=num_days)
previous_end_date = end_date - timedelta(days=num_days)

previous_start_date_persian = gregorian_to_persian(previous_start_date)
previous_end_date_persian = gregorian_to_persian(previous_end_date)

# Selecting category replacement  for widget
selected_category = 'All Categories'

"""<h3>Applying date and category filter on existing dataframes and having two distincts dataframes based on two date ranges</h3><br>
<em>Defined variables: current_filtered_df(first range of dates), previous_filtered_df(second range of dates) <em>

"""

# Filter DataFrame by current and previous date ranges
current_filtered_df = df_orders[(df_orders['Date_Formatted'] >= start_date_persian) & (df_orders['Date_Formatted'] <= end_date_persian)]
previous_filtered_df = df_orders[(df_orders['Date_Formatted'] >= previous_start_date_persian) & (df_orders['Date_Formatted'] <= previous_end_date_persian)]

# Apply category filter if necessary
if selected_category != 'All Categories':
    current_filtered_df = current_filtered_df[current_filtered_df['Category'] == selected_category]
    previous_filtered_df = previous_filtered_df[previous_filtered_df['Category'] == selected_category]

"""<h3>Measuring three essential metrics with filtered dataframes</h3><h6>#They'll get shown at three top-centered scoreboard</h6><br>
<em>current_total_sales, current_total_volume, current_total_net || previous_total_sales, previous_total_volume, previous_total_net <em>

"""

# Calculate metrics for the current date range
current_total_sales = current_filtered_df['TotalPrice'].sum()
current_total_volume = current_filtered_df['Quantity'].sum()
current_total_net = current_filtered_df['TotalNetPrice'].sum()

# Calculate metrics for the previous date range
previous_total_sales = previous_filtered_df['TotalPrice'].sum()
previous_total_volume = previous_filtered_df['Quantity'].sum()
previous_total_net = previous_filtered_df['TotalNetPrice'].sum()

"""<h3>Measuring three essential metrics with filtered dataframes</h3><h6>#They'll get shown at three top-centered scoreboard</h6><br>
<em><strong>defined variables</strong>: current_total_sales, current_total_volume, current_total_net || previous_total_sales, previous_total_volume, previous_total_net <em>

"""

# Calculate growth percentages
sales_growth = ((current_total_sales - previous_total_sales) / previous_total_sales) * 100 if previous_total_sales else 0
volume_growth = ((current_total_volume - previous_total_volume) / previous_total_volume) * 100 if previous_total_volume else 0
net_growth = ((current_total_net - previous_total_net) / previous_total_net) * 100 if previous_total_net else 0

# Formatting the metrics
formatted_total_sales = "{:,}".format(current_total_sales)
formatted_total_volume = "{:,}".format(current_total_volume)
formatted_total_net = "{:,}".format(current_total_net)

"""<h3>Reformatting date string values to persian month names</h3>
<ul>
  <li> dictionary consisting 12 persian month accronyms  </li>
  <li> function which takes standard string date values and turns it into specific format: month name Day</li>
</ul><br>
<em><strong>defined variables: </strong> persian_month, format_persian_date (function) <em>

"""

# Customizing Persian month to corresponding month name by dictionary
persian_months = {'01': 'Far', '02': 'Ord', '03': 'Kho',
                  '04': 'Tir', '05': 'Mor', '06': 'Sha',
                  '07': 'Meh', '08': 'Aba', '09': 'Aza',
                  '10': 'Dey', '11': 'Bah', '12': 'Esf'}

def format_persian_date(date_str):
    if not date_str:
        return None
    parts = date_str.split('-')
    if len(parts) == 3:
        year, month, day = parts
        persian_month = persian_months.get(month, month)
        return f'{persian_month} {day}'
    return date_str

"""<h3>Creating remaining date ranges</h3>
<ul>
  <li> creating date range before from current (selected) date range  </li>
  <li> working with gregorian datetime for calculation and turning the result into standard date values</li>
</ul><br>
<em><strong>defined variables: </strong> additional_ranges, additional_ranges_persian (consisting 6 range of date values including selected ones) <em>

"""

# Create additional date ranges
additional_ranges = []
for i in range(0, 6):
    additional_start_date = start_date - timedelta(days=num_days * i)
    additional_end_date = end_date - timedelta(days=num_days * i)
    additional_ranges.append((additional_start_date, additional_end_date))

# Convert additional date ranges to Persian format
additional_ranges_persian = [(gregorian_to_persian(start), gregorian_to_persian(end)) for start, end in additional_ranges]

additional_ranges_persian

"""<h3>Including all the values from date ranges into combined dataframe</h3><h6>This section is essential for creating a integrated chart</h6>
<em><strong>defined variables: </strong> combined_df, daily_quantity_combined (grouping every date values quantities)<em>

"""

all_ranges_dfs = []

# Adding additional date range data
for idx, (start, end) in enumerate(additional_ranges_persian):
    additional_filtered_df = df_orders[(df_orders['Date_Formatted'] >= start) & (df_orders['Date_Formatted'] <= end)]

    # Apply category filter if necessary
    if selected_category != 'All Categories':
        additional_filtered_df = additional_filtered_df[additional_filtered_df['Category'] == selected_category]
    additional_filtered_df['Range_Number'] = idx

    all_ranges_dfs.append(additional_filtered_df)


combined_df = pd.concat(all_ranges_dfs, ignore_index=True)
# Sort the combined DataFrame by date
combined_df_sorted = combined_df.sort_values(by='Date_Formatted')
# Aggregate total quantity per day for all ranges combined
daily_quantity_combined = combined_df_sorted.groupby('Date_Formatted')['Quantity'].sum().reset_index()

daily_quantity_combined

"""<h3>Converting date values in number format mentioned name of month in persian</h3>"""

# Convert the dates to readable Persian format for plotting
daily_quantity_combined['Date_Formatted'] = daily_quantity_combined['Date_Formatted'].apply(format_persian_date)

daily_quantity_combined

"""<h3>putting simple bar plot with xaxis: all the date in 6 ranges and yaxis: sum of quantity in all the unique date values</h3>"""

# Create a single bar chart with all the data
fig_combined = px.bar(daily_quantity_combined, x='Date_Formatted', y='Quantity', title='Total Quantity per Day - All Date Ranges Combined', color_discrete_sequence=['#636EFA'])
fig_combined.update_xaxes(type='category')

fig_combined.show()

"""<h3>Adding vertical red line to make each date range disparate</h3>
<ul>
<li>positioning each line at the sart of each range</li>
</ul>
"""

line_positions = [end for start, end in additional_ranges_persian]

line_pos = []
for i in line_positions:
  if i in combined_df['Date_Formatted'].unique():
    line_pos.append(i)

line_pos

# Create the bar chart
fig_combined = px.bar(
    daily_quantity_combined,
    x='Date_Formatted',
    y='Quantity',
    title='Total Quantity per Day - All Date Ranges Combined',
    color_discrete_sequence=['#636EFA']
)



# Add red vertical lines at the start of each date range
for line_date in line_pos:
    print(line_date)

    # Add vertical line
    fig_combined.add_vline(x=line_date, fillcolor='red')
# Ensure the x-axis is categorical
fig_combined.update_xaxes(type='category')

fig_combined.show()

"""<h3>Calculating sum of quantity for all the ranges available</h3>
<h6># It is required for proper displayment of the tren line</h6>
"""

# Calculate the average quantity for each segment between red lines
total_quantities = []
average_quantities = []

# Loop through each segment between red lines
for i, ii in additional_ranges_persian:
    end_line = ii
    start_line = i
    print(f'{start_line} and {end_line}')

    # Filter data between the start and end lines
    segment_df = combined_df_sorted[(combined_df_sorted['Date_Formatted'] >= start_line) &
                                    (combined_df_sorted['Date_Formatted'] <= end_line)]


    if not segment_df.empty:
        # Calculate th-e average quantity for this segment
        tot_quantity = segment_df['Quantity'].sum()
        avg_quantity = tot_quantity / num_days
        total_quantities.append((end_line, tot_quantity))
        average_quantities.append((end_line, round(avg_quantity)))

total_quantities

# Handle the final segment after the last red line
#if len(line_positions) > 0:
#    final_segment_df = combined_df_sorted[combined_df_sorted['Date_Formatted'] >= line_positions[-1]]
#    if not final_segment_df.empty:
#        tot_quantity = final_segment_df['Quantity'].sum()
#        total_quantities.append((final_segment_df['Date_Formatted'].max(), tot_quantity))

# Add a trace for the trend line
trend_line_dates = [date for date,_ in total_quantities]
trend_line_values = [quantity for _, quantity in total_quantities]

line_pos

for i in range(len(trend_line_dates)):
  print(trend_line_dates[i], trend_line_values[i])

fig_combined.add_trace(
    go.Scatter(x=[date for date in trend_line_dates],
               y=trend_line_values,
               mode='lines+markers',
               line=dict(color='blue', dash='dash'),
               name='Total Trend')
)

